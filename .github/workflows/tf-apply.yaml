name: Spotify Playlist Updater

on:
  push:
    branches: [ main ]

jobs:
  spotify-auth-and-update:
    runs-on: ubuntu-latest
    name: Authenticate and Update
    timeout-minutes: 15

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Install patched spotify_auth_proxy
        run: go install github.com/gauravslnk/terraform-provider-spotify/tree/fix/base-url-127

      - name: Run auth proxy
        env:
          SPOTIFY_CLIENT_ID: ${{ secrets.SPOTIFY_CLIENT_ID }}
          SPOTIFY_CLIENT_SECRET: ${{ secrets.SPOTIFY_CLIENT_SECRET }}
          SPOTIFY_REDIRECT_URI: ${{ secrets.SPOTIFY_REDIRECT_URI }}
        run: |
          spotify_auth_proxy --port 8080 > proxy.log 2>&1 &
          echo "Waiting for auth URL..."
          for i in {1..30}; do
            if grep -q "Auth URL:" proxy.log; then break; fi
            sleep 1
          done
          auth_url=$(grep "Auth URL:" proxy.log | awk '{print $3}')
          api_key=$(grep "APIKey:" proxy.log | awk '{print $2}')
          echo "AUTH_URL=$auth_url" >> $GITHUB_ENV
          echo "SPOTIFY_API_KEY=$api_key" >> $GITHUB_ENV
          if [ -z "$auth_url" ] || [ -z "$api_key" ]; then
            echo "::error::Failed to get auth credentials"
            cat proxy.log
            exit 1
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install puppeteer@22.8.2 fs-extra@11

      - name: Perform Spotify authentication
        env:
          SPOTIFY_USERNAME: ${{ secrets.SPOTIFY_USERNAME }}
          SPOTIFY_PASSWORD: ${{ secrets.SPOTIFY_PASSWORD }}
        run: |
          node - <<'EOF'
          const puppeteer = require('puppeteer');
          const fs = require('fs-extra');

          // Configuration
          const config = {
            maxRetries: 3,
            timeout: 30000,
            debug: true,
            userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36'
          };

          // Utilities
          const delay = ms => new Promise(r => setTimeout(r, ms));
          const randomDelay = () => Math.floor(Math.random() * 500) + 500;
          const debugLog = (...args) => config.debug && console.log('[DEBUG]', ...args);

          class AuthError extends Error {
            constructor(message, screenshotPath, htmlPath) {
              super(message);
              this.screenshotPath = screenshotPath;
              this.htmlPath = htmlPath;
            }
          }

          async function saveDebugArtifacts(page, prefix) {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const screenshotPath = `${prefix}-${timestamp}.png`;
            const htmlPath = `${prefix}-${timestamp}.html`;
            
            await page.screenshot({ path: screenshotPath, fullPage: true });
            await fs.writeFile(htmlPath, await page.content());
            
            return { screenshotPath, htmlPath };
          }

          async function safeClick(page, selectors, timeout = 10000) {
            const selectorList = Array.isArray(selectors) ? selectors : [selectors];
            
            for (const selector of selectorList) {
              try {
                debugLog(`Attempting to click: ${selector}`);
                await page.waitForSelector(selector, { visible: true, timeout });
                await delay(randomDelay());
                await page.click(selector);
                return true;
              } catch (e) {
                debugLog(`Click failed for ${selector}: ${e.message}`);
              }
            }
            return false;
          }

          async function clickByText(page, text, tag = '*', timeout = 5000) {
            try {
              await page.waitForFunction(
                (text, tag) => {
                  const elements = Array.from(document.querySelectorAll(tag));
                  return elements.some(el => 
                    el.textContent?.trim().toLowerCase().includes(text.toLowerCase())
                  );
                },
                { timeout },
                text,
                tag
              );
              
              const elements = await page.$$(tag);
              for (const element of elements) {
                const elementText = await page.evaluate(el => el.textContent?.trim(), element);
                if (elementText?.toLowerCase().includes(text.toLowerCase())) {
                  await delay(randomDelay());
                  await element.click();
                  return true;
                }
              }
            } catch (e) {
              debugLog(`Text click failed for "${text}": ${e.message}`);
            }
            return false;
          }

          async function typeWithHumanDelay(page, selector, text) {
            await page.focus(selector);
            await delay(randomDelay());
            for (const char of text) {
              await page.keyboard.type(char, { delay: Math.random() * 50 + 50 });
              if (Math.random() > 0.9) await delay(randomDelay());
            }
          }

          async function handleSpotifyAuth(page) {
            // Step 1: Initial navigation
            console.log('üåê Navigating to Spotify auth page...');
            await page.goto(process.env.AUTH_URL, { waitUntil: 'networkidle2' });

            // Check if already authorized
            if (page.url().includes('callback?code=')) {
              console.log('‚úÖ Already authenticated');
              return true;
            }

            // Step 2: Handle cookies
            if (await safeClick(page, ['#onetrust-accept-btn-handler', '.ot-sdk-row button']) || 
                await clickByText(page, 'accept cookies')) {
              console.log('üç™ Accepted cookies');
              await delay(2000);
            }

            // Step 3: Email entry
            console.log('üìß Entering email...');
            await typeWithHumanDelay(page, 'input[type="email"], #login-username', process.env.SPOTIFY_USERNAME);
            
            if (!(await safeClick(page, ['button[data-testid="login-button"]', 'button[type="submit"]']) ||
                  await clickByText(page, 'continue'))) {
              throw new AuthError('Continue button not found', ...await saveDebugArtifacts(page, 'continue-error'));
            }
            await delay(3000);

            // Step 4: Handle OTP/password choice
            const needsPassword = await page.evaluate(() => 
              Array.from(document.querySelectorAll('*'))
                .some(el => el.textContent?.includes('6-digit code'))
            );

            if (needsPassword) {
              console.log('üîÑ Switching to password login...');
              if (!(await clickByText(page, 'log in with a password') ||
                    await safeClick(page, ['button[data-encore-id="buttonTertiary"]', '.auth-footer button']))) {
                throw new AuthError('Password login option not found', ...await saveDebugArtifacts(page, 'password-switch-error'));
              }
              await delay(3000);
            }

            // Step 5: Password entry
            console.log('üîë Entering password...');
            await typeWithHumanDelay(page, 'input[type="password"], #login-password', process.env.SPOTIFY_PASSWORD);
            
            if (!(await safeClick(page, ['button[data-testid="login-button"]', '#login-button']) ||
                  await clickByText(page, 'log in'))) {
              throw new AuthError('Login button not found', ...await saveDebugArtifacts(page, 'login-error'));
            }
            await delay(5000);

            // Step 6: Handle authorization
            let attempts = 0;
            while (attempts < config.maxRetries && !page.url().includes('callback?code=')) {
              attempts++;
              console.log(`üîÑ Authorization attempt ${attempts}/${config.maxRetries}`);
              
              if (await safeClick(page, ['#auth-accept', 'button[data-testid="auth-accept"]']) ||
                  await clickByText(page, 'agree')) {
                console.log('‚úÖ Clicked authorization button');
                await delay(3000);
              }
              
              // Check for errors
              const error = await page.evaluate(() => {
                const errorEl = document.querySelector('[role="alert"], .error, .error-message');
                return errorEl?.textContent?.trim();
              });
              
              if (error) {
                throw new AuthError(`Spotify error: ${error}`, ...await saveDebugArtifacts(page, 'auth-error'));
              }
              
              await delay(2000);
            }

            return page.url().includes('callback?code=');
          }

          async function run() {
            const browser = await puppeteer.launch({
              headless: 'new',
              args: [
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage',
                '--disable-accelerated-2d-canvas',
                '--disable-gpu'
              ],
              defaultViewport: { width: 1280, height: 800 }
            });

            const page = await browser.newPage();
            await page.setUserAgent(config.userAgent);
            page.setDefaultTimeout(config.timeout);

            try {
              const success = await handleSpotifyAuth(page);
              if (!success) {
                throw new AuthError(
                  `Authorization failed after ${config.maxRetries} attempts`,
                  ...await saveDebugArtifacts(page, 'final-error')
                );
              }

              console.log('üéâ Successfully authenticated with Spotify!');
            } finally {
              await browser.close();
            }
          }

          run().catch(async (error) => {
            console.error('‚ùå Authentication failed:', error.message);
            if (error.screenshotPath) {
              console.log(`üì∏ Screenshot saved to: ${error.screenshotPath}`);
            }
            if (error.htmlPath) {
              console.log(`üìÑ HTML saved to: ${error.htmlPath}`);
            }
            process.exit(1);
          });
          EOF

      - name: Run Terraform
        run: |
          terraform init
          terraform apply -var="spotify_api_key=${{ env.SPOTIFY_API_KEY }}" -auto-approve

      - name: Upload debug artifacts
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: auth-debug
          path: |
            *.png
            *.html
            proxy.log